#lang racket
(require "lib/qiudao.rkt")
(define (sum? x)
  (and (pair? x) (eq? (cadr x) `+)))
(define (product? x)
  (and (pair? x) (eq? (cadr x) `*)))

;sum
(define addend car)

(define (make-sum x y)
  (cond ((=number? x 0) y)
        ((=number? y 0) x)
        ((and (number? x) (number? y)) (+ x y))
        (else (list x `+  y))))
;product
(define multiplier car)

(define (make-product x y)
  (cond ((or(=number? x 0) (=number? y 0)) 0)
        ((=number? x 1) y)
        ((=number? y 1) x)
        ((and (number? x) (number? y)) (* x y))
        (else (list x `*  y))))
(define (deriv exp var)
  (cond ((number? exp) 0)
        ((variable? exp)
         (if (same-variable? exp var) 1 0))
        ((sum? exp)
         ;(display "make-sum")
         (make-sum (deriv (addend exp) var)
                   (deriv (augend exp) var)))
        ((product? exp)
         (make-sum
         (make-product (multiplier exp)
                       (deriv (multiplicand exp) var))
         (make-product (deriv (multiplier exp) var)
                       (multiplicand exp))))  
        (else
         (error "unkonw expression type --DERIV" exp))))
(define (multiplicand m)
    (let ((rest (cddr m)))
    (if (null? (cdr rest))
         (car rest)
         rest
       )))
(define (augend m)
  (let ((rest (cddr m)))
    (if (null? (cdr rest))
         (car rest)
         rest
       )))
(define a `(x * (y * (x + 3))))
(define b `(x + 3 * (x + y + 2)))
(define c `(x + y + 2))
(deriv a `x)