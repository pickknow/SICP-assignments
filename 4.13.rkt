#lang racket
(define (variable-abs var val env op1 op2)
  (define (env-loop env)
    (define (scan vars vals)
      (cond ((null? vars)
             (op1 env-loop var val env vars vals)
             (env-loop (enclosing-environment env)))
            ((eq? var (car vars))
             (op2 env-loop var val env vars vals)
            (else (scan (cdr vars) (cdr vals)))))
    (if (eq? env the-empty-environment)
        (error "Unbound variable" var)
        (let ((frame (first-frame env)))
          (scan (frame-variables frame)
                (frame-values frame)))))
  (env-loop env)))
(define (lookup-variable-value var env)
  ((variable-abs var `() env)
   (lambda (env-loop var val env vars vals)
     (env-loop (enclosing-environment env)))
   (lambda (env-loop var val env vars vals)
     (car vals)))) 
(define (set-variable-value! var val env)
    ((variable-abs var val env)
   (lambda (env-loop var val env vars vals)
     (env-loop (enclosing-environment env)))
   (lambda (env-loop var val env vars vals)
      (set-car! vals val))))
(define (define-variable! var val env)
  ((variable-abs var val env)
   (lambda (env-loop var val env vars vals)
     (add-binding-to-frame! var val frame))
   (lambda (env-loop var val env vars vals)
     (set-car! vals val))))
(define (make-unbound! var env)
  ((variable-abs var val env)
   (lambda (env-loop var val env vars vals)
     true)
   (lambda (env-loop var val env vars vals)
     (set-car! vals `())
     (set-cdr! vals `()))))
  
