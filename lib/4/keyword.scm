(load "util.scm")
(define (assignment? exp)
  (tagged-list? exp 'set!))
(define (assignment-variable exp) (cadr exp))
(define (assignment-value exp) (caddr exp))


(define (definition? exp)
  (tagged-list? exp 'define))
(define (definition-variable exp)
  (if (symbol? (cadr exp))
      (cadr exp)
      (caadr exp)))
(define (definition-value exp)
  (if (symbol? (cadr exp))
      (caddr exp)
      (make-lambda (cdadr exp)
                   (cddr exp))))
(define (eval-definition exp env)
  (define-variable! (definition-variable exp)
                    (eval (definition-value exp) env)
                    env)
  'ok)


(define (lambda? exp) (tagged-list? exp 'lambda))
(define (lambda-parameters exp) (cadr exp))
(define (lambda-body exp) (cddr exp))
(define (make-lambda parameters body)
  (cons 'lambda (cons parameters body)))


(define (if? exp) (tagged-list? exp 'if))
(define (if-predicate exp) (cadr exp))
(define (if-consequent exp) (caddr exp))
(define (if-alternative exp)
  (if (not (null? (cdddr exp)))
      (cadddr exp)
      'false))

(define (make-if predicate consequent alternative)
  (list 'if predicate consequent alternative))
(define (eval-if exp env)
  (if (true? (eval (if-predicate exp) env))
      (eval (if-consequent exp) env)
      (eval (if-alternative exp) env)))


(define (eval-sequence exps env)
 (display exps)(newline)
  (cond ((last-exp? exps) (eval (first-exp exps) env))
        (else (eval (first-exp exps) env)
              (eval-sequence (rest-exps exps) env))))
(define (eval-assignment exp env)
  (set-variable-value! (assignment-variable exp)
                       (eval (assignment-value exp) env)
                       env)
  'ok)

(define (and? exp) (tagged-list? exp 'and))
(define (and-first exp) (cadr exp))
(define (and-second exp) (caddr exp))
(define (eval-and exp env)
  (let ((result (eval (and-first exp) env)))
   (if (true? result)
       (eval (and-second exp) env)
       false)))

(define (or? exp) (tagged-list? exp 'or))
(define (or-first exp) (cadr exp))
(define (or-second exp) (caddr exp))
(define (eval-or exp env)
 (let ((result (eval (or-first exp) env)))
  (if (true? result)
      result
      (eval (and-second exp) env))))

(define (let? exp) (tagged-list? exp 'let))
(define (let-special? exp) (symbol? (cadr exp)))
(define (let-special-name exp)(cadr exp))
(define (let-list exp)
  (if (let-special? exp)
      (caddr exp)
      (cadr exp)))
(define (let-body exp)
  (if (let-special? exp)
      (cadddr exp)
      (cddr exp)))
(define (let-variables exp)
  (map car (let-list exp)))
(define (let-values exp)
  (map cadr (let-list exp)))
(define (make-let-normal exp)
     (cons (make-lambda
   		(let-variables exp)
		(let-body exp))
	(let-values exp)))

(define (make-let-named exp)
  (list 'let (let-list exp)
        (list 'define (cons (let-special-name exp)
                            (let-variables exp))
              (let-body exp))
        (cons (let-special-name exp) (let-variables exp))))

(define (make-let-named2 expression)
  (let* ((var-name (cadr expression))
         (let-list (caddr expression))
         (arg-list (map car let-list))
         (arg-init (map cadr let-list))
         (let-body (cdddr expression)))
    (list 'let
          (list (list var-name
                      (make-lambda arg-list let-body)))
          (cons var-name arg-init))))

(define (let->combination exp)
  (if (let-special? exp)
      (make-let-named exp)
      (make-let-normal exp)))



(define (let*? exp) (tagged-list? exp 'let*))
(define let*-binding cadr)
(define let*-body cddr)
(define (let*->nested-lets exp)
  (let ((vars (let*-binding exp)))
    (define (make-let* var-list)
      (if (null? (cdr var-list))
          (append (list 'let)
                  (list (list (car var-list)))
                  (let*-body exp))
          (list 'let
                (list (car var-list))
                (make-let* (cdr var-list)))))
    (make-let* (let*-binding exp))))

(define (for? exp) (tagged-list? exp 'for))
(define (for-init exp) (cadr exp))
(define (for-cond exp) (caddr exp))
(define (for-change exp) (cadddr exp))
(define (for-body exp) (car (cddddr exp)))
(define (for->combination exp)
  (cons 'begin (list (for-init exp)
        (list 'define (list 'for-iter)
              (make-if (for-cond exp)
                       (cons 'begin (list (for-body exp)
                                          (for-change exp)
                                          (list 'for-iter)))
                       'true))
        (list 'for-iter))))

(define (unbound? exp) (tagged-list? exp 'unbound!))
(define (unbond-var exp) (cadr exp))
(define (eval-unbound exp env)
  (make-unbound! (unbond-var exp) env))

(define (letrec? exp) (tagged-list? exp 'letrec))
(define (letrec-list exp) (cadr exp))
(define (letrec-body exp) (cddr exp))
(define (letrec-define lst)      
  (cons
   (map (lambda (x)
          (list (car x) ''*unassigned*))
        lst)
   (map (lambda (x)
          (list 'set! (car x)  (cadr x)))
        lst)))
(define (letrec->exp exp)
  (let ((lets (letrec-define (letrec-list exp))))
   (list 'let  (car lets)
             (make-begin (append (cdr lets) (letrec-body exp))))))

