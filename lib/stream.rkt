#lang racket
(provide the-empty-stream)
(define the-empty-stream empty-stream)
(provide stream-null?)
(define stream-null? stream-empty?)
(provide stream-car)
(define stream-car stream-first)
(provide stream-cdr)
(define stream-cdr stream-rest)
(provide zip-map)
(define (zip-map proc . agrstreams)
  (if (null? (car agrstreams))
      the-empty-stream
      (stream-cons
       (apply proc (map stream-car agrstreams))
       (apply zip-map
              (cons proc (map stream-cdr agrstreams))))))
(provide add-streams)
(define (add-streams s1 s2)
  (zip-map + s1 s2))
(provide mul-streams)
(define (mul-streams s1 s2)
  (zip-map * s1 s2))
(provide scale-streams)
(define (scale-streams s fac)
  (stream-map (lambda (x) (* x fac)) s))
(define (integers-starting-from n)
  (stream-cons n (integers-starting-from (+ n 1))))
(provide integers)
(define integers (integers-starting-from 1))
(provide stream-top)
(define (stream-top s n)
  (if (< n 0)
      (displayln `done)
      (begin
        (displayln (stream-car s))
        (stream-top (stream-cdr s) (- n 1)))))

(provide display-stream)
(define (display-stream s)
  (stream-for-each display-line s))
(provide display-line)
(define (display-line x)
  (newline)
  (display x))

(provide memo-proc)
(define (memo-proc proc)
  (let ((already-run? #f) (result #f))
    (lambda ()
      (if (not already-run?)
          (begin (set! result (proc))
                 (set! already-run? #t)
                 result)
          result))))
(provide stream-enumerate-interval)
(define (stream-enumerate-interval low high)
  (if (> low high)
      the-empty-stream
      (stream-cons
       low
       (stream-enumerate-interval (+ low 1) high))))

